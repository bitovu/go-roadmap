# `if`, `switch` и `make` в Go

---

## Краткий ответ на собеседовании

В Go условная логика реализуется через конструкции `if` и `switch`.  
`if` используется для проверки условий, `switch` — для удобной обработки
нескольких вариантов.  
Функция `make` применяется для инициализации встроенных ссылочных типов:
`slice`, `map` и `channel`.

---

## `if`

### Обычное условие

```go
if x > 10 {
    fmt.Println("x больше 10")
}
```
-круглые скобки не используются
-тело условия всегда в фигурных скобках

## if / else
```go
if x > 10 {
    fmt.Println("x больше 10")
} else {
    fmt.Println("x меньше или равен 10")
}
```

## if с инициализацией
```go
if n := len(s); n > 0 {
    fmt.Println("строка не пустая")
}
```
-переменная n существует только внутри `if`

## `switch` в Go

```go
switch x {
case 1:
    fmt.Println("один")
case 2, 3:
    fmt.Println("два или три")
default:
    fmt.Println("другое значение")
}
```
- `switch` сравнивает значение с вариантами `case`
- `break` писать не нужно — он добавляется автоматически
-можно указывать несколько значений в одном `case`

## `make` в Go

`make` используется для создания и инициализации встроенных ссылочных типов:
`slice`, `map` и `channel`.

```go
// slice
s := make([]int, 0, 10)

// map
m := make(map[string]int)
m["a"] = 1

// channel
ch := make(chan int)
```

- `make` не возвращает указатель
- подготавливает внутреннюю структуру типа
- без `make` `map` и `channel` использовать нельзя

---

## `make` vs `new`

```go
p := new(int)
```
- `new` выделяет память и возвращает указатель
- `make` инициализирует` slice`, `map`, `channel`

⬅️ [гет бэк](../)
