# Worker Pool pattern

← [К списку паттернов](README.md)

## Коротко для собеседования

**Worker Pool** — это паттерн конкурентности,
при котором фиксированное количество воркеров
читает задачи из общей очереди и обрабатывает их параллельно.

Количество goroutine заранее ограничено.

---

## Когда использовать

- одна функция обработки
- поток независимых задач
- нужно ограничить параллелизм
- простая и понятная архитектура

---

## Когда НЕ использовать

- несколько последовательных этапов обработки (лучше pipeline)
- разные типы воркеров с разной логикой
- сложные зависимости между задачами

---

## Схема

1. Есть входной канал с задачами (`jobs`)
2. Запускается фиксированное количество воркеров
3. Каждый воркер:
   - читает задачу из `jobs`
   - выполняет обработку
   - отправляет результат в `results`
4. Результаты читаются из одного выходного канала

---

## Минимальный пример (идея)

```go
func worker(jobs <-chan int, results chan<- int) {
	for job := range jobs {
		results <- job * 2
	}
}
```

# Ключевые правила

- количество воркеров фиксировано

- все воркеры читают из одного входного канала

- воркеры не знают друг о друге

- закрытие каналов управляется снаружи

# Типичные ошибки 

- создание слишком большого количества воркеров

- забыли закрыть входной канал

- попытка использовать worker pool для pipeline-задач

# Связь с другими паттернами

- Worker Pool — самый простой и практичный паттерн

- Fan-out / Fan-in — более гибкий, но сложнее

- Pipeline — для многоэтапной обработки данных
