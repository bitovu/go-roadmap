# Каналы доьна

> Конспект по каналам в Go: **как ответить на собесе** и **как реально понимать и использовать**.
> Написано простым языком, без заучивания, с правильной ментальной моделью.

---

## 1. Как отвечать на собесе (коротко и уверенно)

### Что такое канал в Go?

**Канал — это средство передачи данных и синхронизации между goroutine.**
Он позволяет goroutine безопасно обмениваться значениями без shared memory и mutex.

Ключевая идея Go:

> *Don’t communicate by sharing memory; share memory by communicating.*

---

### Чем канал отличается от mutex?

* `mutex` защищает **общую память**
* `channel` передаёт **сообщения** и **синхронизирует выполнение**

Канал — это не просто блокировка, а **контракт взаимодействия**.

---

### Небуферизированный vs буферизированный канал

* **Небуферизированный** (`make(chan T)`):

  * точка встречи
  * запись блокируется, пока кто-то не прочитает
  * чтение блокируется, пока кто-то не запишет

* **Буферизированный** (`make(chan T, N)`):

  * есть очередь на `N` значений
  * можно писать без читателя, пока буфер не заполнен
  * используется для rate limiting / backpressure

---

### Когда закрывать канал?

* Канал закрывает **тот, кто в него пишет**
* Закрывать нужно, **когда значений больше не будет**
* Закрытие — это **сигнал окончания данных**, а не освобождение памяти

Важно:

* канал **не всегда нужно закрывать**
* если известно точное количество чтений — `close` не нужен
* если используется `for range` — канал **обязан быть закрыт**

---

### Что делает `close(ch)`?

* сигнализирует: **новых значений больше не будет**
* не останавливает goroutine
* не освобождает память
* не делает канал `nil`

Чтение из закрытого канала:

* не блокируется
* возвращает **zero value**

Запись в закрытый канал:

* **panic**

---

### Что такое `select`?

`select` выбирает **готовую неблокирующую операцию** с каналом.

* если есть готовый case — выполняется сразу
* если все case блокирующие и **нет `default`** — `select` блокируется
* если есть `default` — `select` **никогда не блокируется**

---

### Чем опасен `select` с `default`?

* легко создать **busy loop** (100% CPU)
* возможна тихая потеря данных

Использовать `default` нужно **осознанно**.

---

## 2. Базовая ментальная модель каналов

### Главное правило

> **Канал — это не магия. Это очередь + ожидание + замок.**

---

### Небуферизированный канал

* нет хранения значений
* передача происходит «из рук в руки»
* гарантирует факт коммуникации

Формула:

> *Передал = кто-то принял*

---

### Буферизированный канал

* есть очередь значений
* коммуникация не гарантируется
* можно «написать и прочитать самому»

Формула:

> *Положил ≠ кто-то принял*

Буфер — это **компромисс**, а не улучшение по умолчанию.

---

## 3. Close, range и жизненный цикл канала

### `for range ch`

* читает значения, пока канал **не закрыт**
* без `close` — вечная блокировка

---

### Кто НЕ должен закрывать канал

* консюмер
* случайные goroutine

Причина:

* они не знают, будут ли ещё записи

---

## 4. Pipeline-паттерн (то, что ты реально учил)

### Суть паттерна

> **Pipeline — это цепочка goroutine, соединённых каналами.**

Каждый этап:

* читает из входного канала
* обрабатывает данные
* пишет в выходной канал
* закрывает ТОЛЬКО свой выходной канал

---

### Типовая сигнатура этапа

```go
func stage(in <-chan T) <-chan U
```

Почему так:

* `<-chan` — нельзя писать и закрывать
* `chan<-` — нельзя читать
* компилятор защищает дизайн

---

### Микропаттерн создания канала

Если функция **создаёт канал и возвращает его**:

* она **не должна блокироваться**
* запись должна быть в отдельной goroutine

Это предотвращает deadlock.

---

## 5. Busy loop

### Что это такое

> **Busy loop — это цикл без ожидания, который жрёт CPU.**

Часто возникает из-за:

```go
select {
case <-ch:
default:
}
```

---

### Как избежать

* убрать `default`
* добавить `Sleep`
* использовать `time.After`, `ticker`, `context`

---

## 6. Под капотом (ровно столько, сколько нужно)

### Что есть внутри канала концептуально

* буфер (или его отсутствие)
* размер буфера (capacity)
* текущее количество элементов
* указатель на буфер
* **sendx / recvx** — куда писать / откуда читать
* **sendq / recvq** — очереди ожидания goroutine
* mutex (lock)
* флаг `closed`

---

### Главное правило внутренних полей

> **`x` — это КУДА, `q` — это КТО.**

* `sendx`, `recvx` — индексы в буфере
* `sendq`, `recvq` — goroutine, которые ждут

В `waitq` попадают **goroutine**, а не данные и не указатели.

---

## 7. Финальная формула (самое важное)

> **Канал — это потокобезопасная очередь сообщений,
> где goroutine либо передают данные,
> либо засыпают и ждут.**

Если ты это понимаешь — ты **понимаешь каналы в Go**.

---

## 8. Что НЕ нужно заучивать

* внутренние структуры runtime
* имена полей (`hchan`, `sudog`, `waitq`)
* размеры типов

Важно понимать **поведение**, а не реализацию.

---

## 9. Короткая шпаргалка

* канал ≠ очередь сообщений
* буфер ≠ ускорение
* close = сигнал, не cleanup
* `default` = отказ ждать
* `range` ждёт `close`

---

## 10. Итог

Ты знаешь каналы, если:

* понимаешь блокировки
* понимаешь жизненный цикл
* понимаешь, кто владеет каналом
* не боишься `select`

Этого достаточно для продакшена и собеседований.
