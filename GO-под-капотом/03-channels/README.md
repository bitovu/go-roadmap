# Channels под капотом (Go)

---

## Channels в Go — кратко для собеседования

`channel` в Go — это механизм передачи данных и синхронизации между goroutine.

Каналы реализуют **message passing** (обмен сообщениями),
в отличие от **shared memory** (общей памяти),
где несколько goroutine напрямую работают с одними и теми же данными.

> Don’t communicate by sharing memory; share memory by communicating.  
> *Не общайтесь, делясь памятью; делитесь памятью, общаясь.*

Канал блокирует goroutine, если операция невозможна,
и разблокирует её, когда появляется вторая сторона.

---

## Небуферизированный канал (`make(chan T)`)
```go
Операция \ Состояние   | Открыт                | Закрыт                       | Неинициализирован (nil)
------------------------|-----------------------|------------------------------|--------------------------
Чтение (<-ch)          | ⏳ блок               | ✅ zero value                | ⏳ блок навсегда
Запись (ch <- v)       | ⏳ блок               | ❌ PANIC                     | ⏳ блок навсегда
close(ch)              | ✅ закрывает          | ❌ PANIC                     | ❌ PANIC
```
---

## Буферизированный канал (`make(chan T, N)`)
```go
Операция \ Состояние   | Открыт, буфер пуст        | Открыт, буфер не пуст     | Открыт, буфер полон      | Закрыт
------------------------|---------------------------|----------------------------|---------------------------|------------------------
Чтение (<-ch)          | ⏳ блок                   | ✅ читает                 | ✅ читает                | ✅ остатки → zero value
Запись (ch <- v)       | ✅ пишет                  | ✅ пишет                  | ⏳ блок                  | ❌ PANIC
```

---

## Ключевые свойства каналов

- канал может быть **открыт**, **закрыт** или **nil**
- закрытие канала — это **сигнал окончания данных**, а не освобождение памяти
- чтение из закрытого канала:
  - не блокируется
  - возвращает **zero value**
- запись в закрытый канал:
  - всегда **PANIC**
- `nil`-канал:
  - чтение и запись блокируются навсегда

---

## Select (кратко)

- `select` выбирает **готовую неблокирующую операцию**
- если все case блокирующие и нет `default` — `select` блокируется
- `default` делает `select` неблокирующим

Неправильное использование `select { default }` может привести к **busy loop**
(100% загрузка CPU).

---

## Pipeline-паттерн

Pipeline — это цепочка goroutine, соединённых каналами.

Каждый этап:
- читает из входного канала
- обрабатывает данные
- пишет в выходной канал
- закрывает **только свой выходной канал**

Типовая сигнатура этапа:

```go
func stage(in <-chan T) <-chan U
```

## Под капотом (минимум, который нужно знать)

Концептуально канал содержит:

- буфер (или его отсутствие)

- ёмкость буфера

- текущее количество элементов

- указатель на буфер

- sendx, recvx — куда писать / откуда читать

- sendq, recvq — очереди ожидающих goroutine

- mutex (lock)

- флаг closed

## Правило для запоминания:

x — это КУДА, q — это КТО

В очереди ожидания (sendq, recvq) попадают goroutine, а не данные.
