# Go: Горутины

## Что такое горутина
**Горутина** — это лёгкий поток выполнения, управляемый рантаймом Go.

## Золотое правило
> Горутина должна либо завершаться, либо быть управляемой

Особенности:
- создаётся очень дёшево
- не привязана напрямую к OS-потоку
- запускается параллельно с другими горутинами
- управляется Go runtime, а не ОС

---

## Зачем нужны горутины
Используются для:
- параллельных вычислений
- асинхронной работы
- обработки запросов
- фоновых задач
- конкурентных пайплайнов

Главная идея:
> много логических потоков поверх малого числа системных потоков

---

## Жизненный цикл горутины
1. Создаётся
2. Ставит задачу на выполнение
3. Выполняется
4. Может быть:
   - приостановлена
   - продолжена
   - завершена
5. После завершения полностью уничтожается

Важно:
- завершённую горутину нельзя «перезапустить»
- если `main` завершился — все горутины завершаются

---

## Планировщик Go (Scheduler)

Go использует модель **GMP**:
- **G (Goroutine)** — задача
- **M (Machine)** — OS-поток
- **P (Processor)** — логический процессор

Идея:
- множество G
- ограниченное число P
- M выполняют G через P

---

## Как горутины планируются
- планирование кооперативное + прерываемое
- Go сам решает, когда переключать горутины
- переключение дешевле, чем у OS-потоков

Причины переключения:
- блокировка (I/O, mutex, channel)
- явная уступка выполнения
- системный вызов
- таймеры

---

## Кеширование и переиспользование

Кешируется и переиспользуется:
- стеки горутин
- OS-потоки (M)
- внутренние структуры планировщика

Стек горутины:
- начинается маленьким
- растёт и уменьшается динамически
- не фиксированного размера

Это делает горутины:
- дешёвыми по памяти
- масштабируемыми (тысячи и миллионы)

---

## Сколько горутин можно создавать
Практически:
- тысячи — норма
- десятки тысяч — нормально
- сотни тысяч — возможно
- миллионы — осторожно

Ограничения:
- память
- блокировки
- логика синхронизации

---

## Типичные ошибки
- утечки горутин (они ждут и не завершаются)
- ожидание, что горутина выполнится без синхронизации
- блокировка всех P
- запуск без контроля завершения

---

## Когда горутины — плохая идея
- CPU-bound задачи без ограничения
- отсутствие синхронизации
- бесконтрольный запуск в циклах
- замена простого кода «на всякий случай»

---

## Коротко
- горутина ≠ поток ОС
- дешёвая и масштабируемая
- управляется Go runtime
- требует контроля жизненного цикла

---

 ⬅️ [домой,уолтер](../)
