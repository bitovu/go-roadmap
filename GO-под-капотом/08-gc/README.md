<div align="center" style="margin-top: 40px;">

<div style="display: flex; align-items: center; justify-content: center; gap: 16px;">
  <h1 style="margin: 0;">гарбаге коллектор</h1>
</div>


</div>



## 1. Зачем нужен GC

GC (Garbage Collector) нужен, чтобы:

* автоматически **освобождать память в куче**
* не допускать утечек памяти
* позволить программисту не управлять `malloc/free`

GC **управляет памятью только в куче**, а стек **использует как источник корней (root set)**: он читает указатели со стека, но не управляет памятью стека.

---

## 2. Куча и стек (контекст)

* **Стек**:

  * локальные переменные функций
  * время жизни = время вызова функции
  * GC его **только сканирует**

* **Куча**:

  * объекты с неопределённым временем жизни
  * именно здесь работает GC

---

## 3. Root set (корни)

GC начинает не с кучи, а с **корней**: `короче гц сканирует кучу, а стеки использует как стартовые ссылки`

* стеки всех горутин
* глобальные переменные
* некоторые runtime-структуры

Корни — это **источники ссылок в кучу**.

---

## 4. Трёхцветная модель (tri-color)

Каждый объект в куче логически имеет цвет:

* **Белый** — объект ещё не признан достижимым
* **Серый** — объект достижим, но его поля ещё не просмотрены
* **Чёрный** — объект достижим и полностью обработан

> В конце GC все **белые объекты считаются мусором**.

---

## 5. Инвариант трёх цветов

**Ключевое правило:**

> ❗ Чёрный объект **никогда не должен указывать на белый**

Почему:

* чёрные объекты GC больше не сканирует
* белый объект может быть ошибочно удалён

---

## 6. Общий алгоритм GC (уточнённый)

### Шаг 1. Старт цикла

* Вся куча **логически считается белой**
* GC не перекрашивает каждый объект физически

### Шаг 2. Скан корней

* GC сканирует стеки и глобалы
* найденные объекты в куче → **серые**

### Шаг 3. Маркировка (mark)

* берётся серый объект
* его поля сканируются
* найденные белые → серые
* текущий объект → чёрный

### Шаг 4. Sweep

* все оставшиеся белые объекты → освобождаются

---

## 7. Write Barrier (очень важно)

GC в Go работает **параллельно с программой**.

Проблема:

```go
black.field = white
```

Решение:

* write barrier **перекрашивает white в серый**
* инвариант сохраняется

GC не следит за всеми указателями постоянно — barrier нужен для корректности.

---

## 8. GC и стек

Важно строго разделять понятия **сканирование** и **управление памятью**.

* GC **сканирует стек**:

  * читает указатели, лежащие в стеке горутин
  * использует их для формирования **root set** (Root set — это стартовые ссылки, из которых GC находит живые объекты)
  * не помечает стек цветами
  * не освобождает и не управляет памятью стека

* GC **не собирает мусор в стеке** — стек очищается автоматически при выходе из функций.

Именно поэтому корректно говорить:

> **GC сканирует стек, чтобы найти корни, и сканирует кучу, чтобы помечать и освобождать объекты.**

---

## 9. Stop-the-World (STW)

Полного STW почти нет, но есть **короткие паузы**:

* старт GC
* завершение GC

В это время:

* останавливаются горутины
* GC получает консистентное состояние

---

## 10. Что GC НЕ делает

GC:

* ❌ не управляет стеком
* ❌ не двигает объекты в куче
* ❌ не знает про значения без ссылок
* ❌ не видит объекты, если на них нет путей из корней

---

## 11. Связь с рантаймом

GC — часть **Go runtime** и работает вместе с:

* планировщиком (scheduler)
* аллокатором памяти
* stack manager

---

## 12. Короткий конспект

* GC работает **с кучей**
* стек используется как **root set**
* модель: **white → gray → black**
* инвариант: **black → white запрещено**
* write barrier сохраняет корректность

---

## 13. Главное, что нужно понять

> **GC не ищет мусор.
> Он ищет живые объекты.
> Всё остальное — мусор.**

---

* методичку "GC + scheduler вместе"
