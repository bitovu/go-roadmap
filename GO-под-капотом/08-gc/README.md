

## 1. Зачем нужен GC

GC (Garbage Collector) нужен, чтобы:

* автоматически **освобождать память в куче**
* не допускать утечек памяти
* позволить программисту не управлять `malloc/free`

GC **не работает со стеком**, он работает **только с кучей**.

---

## 2. Куча и стек (контекст)

* **Стек**:

  * локальные переменные функций
  * время жизни = время вызова функции
  * GC его **только сканирует**

* **Куча**:

  * объекты с неопределённым временем жизни
  * именно здесь работает GC

---

## 3. Root set (корни)

GC начинает не с кучи, а с **корней**:

* стеки всех горутин
* глобальные переменные
* некоторые runtime-структуры

Корни — это **источники ссылок в кучу**.

---

## 4. Трёхцветная модель (tri-color)

Каждый объект в куче логически имеет цвет:

* **Белый** — объект ещё не признан достижимым
* **Серый** — объект достижим, но его поля ещё не просмотрены
* **Чёрный** — объект достижим и полностью обработан

> В конце GC все **белые объекты считаются мусором**.

---

## 5. Инвариант трёх цветов

**Ключевое правило:**

> ❗ Чёрный объект **никогда не должен указывать на белый**

Почему:

* чёрные объекты GC больше не сканирует
* белый объект может быть ошибочно удалён

---

## 6. Общий алгоритм GC

### Шаг 1. Старт цикла

* Вся куча **логически считается белой**
* GC не перекрашивает каждый объект физически

### Шаг 2. Скан корней

* GC сканирует стеки и глобалы
* найденные объекты в куче → **серые**

### Шаг 3. Маркировка (mark)

* берётся серый объект
* его поля сканируются
* найденные белые → серые
* текущий объект → чёрный

### Шаг 4. Sweep

* все оставшиеся белые объекты → освобождаются

---

## 7. Write Barrier (очень важно)

GC в Go работает **параллельно с программой**.

Проблема:

```go
black.field = white
```

Решение:

* write barrier **перекрашивает white в серый**
* инвариант сохраняется

GC не следит за всеми указателями постоянно — barrier нужен для корректности.

---

## 8. GC и стек

* Стек **не имеет цветов**
* GC **читает указатели**, лежащие в стеке
* для этого используются **stack maps**, созданные компилятором

GC знает:

* где указатель
* где не указатель

---

## 9. Stop-the-World (STW)

Полного STW почти нет, но есть **короткие паузы**:

* старт GC
* завершение GC

В это время:

* останавливаются горутины
* GC получает консистентное состояние

---

## 10. Что GC НЕ делает

GC:

* ❌ не управляет стеком
* ❌ не двигает объекты в куче
* ❌ не знает про значения без ссылок
* ❌ не видит объекты, если на них нет путей из корней

---

## 11. Связь с рантаймом

GC — часть **Go runtime** и работает вместе с:

* планировщиком (scheduler)
* аллокатором памяти
* stack manager

---

## 12. Короткий конспект

* GC работает **с кучей**
* стек используется как **root set**
* модель: **white → gray → black**
* инвариант: **black → white запрещено**
* write barrier сохраняет корректность

---

## 13. Главное, что нужно понять

> **GC не ищет мусор.
> Он ищет живые объекты.
> Всё остальное — мусор.**

---

* методичку по **stack manager**
* методичку "GC + scheduler вместе"
