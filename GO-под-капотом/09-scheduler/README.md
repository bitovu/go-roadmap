# Планировщик горутин в Go (Scheduler)

---

## 1. Зачем нужен планировщик

Планировщик (scheduler) нужен, чтобы:

* выполнять **тысячи и миллионы горутин**
* не создавать под каждую поток ОС
* эффективно использовать CPU

Планировщик — **часть Go runtime**.


Главная мысль

> **Планировщик позволяет миллионам горутин эффективно работать на ограниченном числе потоков ОС.**


---

## 2. Базовая модель: M : P : G

### G — goroutine

* функция + стек + состояние
* то, что **нужно выполнить**

### M — machine

* поток операционной системы (OS thread)
* то, что **реально выполняет инструкции на CPU**

### P — processor

* логический процессор рантайма
* даёт право **выполнять Go-код**
* хранит локальную очередь горутин

> **M выполняет G, имея P**

---

## 3. Как выполняется горутина

1. Создаётся `G` (goroutine)
2. Она кладётся в очередь `P`
3. Поток `M` берёт `P`
4. `M` выполняет `G` на CPU

Важно:

* без `P` поток `M` **не может выполнять Go-код**
* `GOMAXPROCS` = количество `P`

---

## 4. Очереди горутин

* **Локальная очередь P** — основная
* **Глобальная очередь** — резерв

Планировщик сначала берёт горутины из **локальной очереди**, чтобы:

* меньше блокировок
* лучше кэш-локальность

---

## 5. Work Stealing

Если у `P` закончилась работа:

* он **ворует** горутины у другого `P`
* это называется **work stealing**

Позволяет равномерно загрузить CPU.

---

## 6. Блокировки и парковка горутин

Когда горутина:

* ждёт канал
* ждёт mutex
* ждёт I/O

Она:

* **паркуется** (sleep)
* не занимает CPU
* не блокирует поток ОС

Планировщик запускает другую `G`.

---

## 7. Syscall и планировщик

Если горутина делает syscall:

* поток `M` может заблокироваться
* runtime **отцепляет P от M**
* другой `M` подхватывает `P`

Это предотвращает простой CPU.

---

## 8. Preemption (вытеснение)

Чтобы горутина не захватила CPU навсегда:

* runtime может **принудительно прервать** её
* переключить выполнение на другую

Это важно для fairness.

---

## 9. Scheduler и GC

* GC и scheduler работают вместе
* во время STW планировщик:

  * останавливает все `G`
  * переводит их в safe point

После STW выполнение продолжается.

---

## 10. Что планировщик НЕ делает

Планировщик:

* ❌ не управляет памятью
* ❌ не делает GC
* ❌ не работает со стеком напрямую

Он **только управляет выполнением**.

---

## 11. Короткий конспект

* `G` — задача
* `M` — поток ОС
* `P` — право выполнять Go-код
* `M executes G while holding P`
* локальные очереди + work stealing

---


