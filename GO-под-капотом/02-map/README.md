# Map под капотом (Go)

---

## Краткий ответ на собеседовании

`map` в Go — это **хеш-таблица**.  
Внутри она состоит из массива бакетов, использует хеширование **ключей**
для быстрого доступа и автоматически растёт за счёт механизма **grow**
с постепенной эвакуацией элементов.
`map` не является потокобезопасной.

---

## Общая структура `map`

На уровне реализации `map` включает:

- массив бакетов
- хеш-функцию (зависит от типа ключа)
- счётчик элементов
- структуру для управления ростом (`B`, `oldbuckets`, счётчик эвакуации)

Данные в `map` **не хранятся последовательно** —
они распределяются по бакетам на основе хеша ключа.

---

## Бакеты (buckets)

Каждый бакет содержит:

- до **8 ключей**
- соответствующие значения
- массив `tophash` (8 старших бит хеша ключа)
- указатель на overflow-бакет (если бакет переполнен)

Если в одном бакете больше 8 элементов,
создаётся **overflow-бакет**, связанный с основным.

Overflow — это локальное решение и **не означает рост всей map**.

---

## Хеширование ключей

При добавлении или поиске элемента:

1. **ключ хешируется**
2. младшие биты хеша определяют индекс бакета
3. `tophash` используется как быстрый фильтр внутри бакета
4. при совпадении `tophash` выполняется сравнение реальных ключей

```go
m := make(map[string]int)
m["go"] = 1
```

## Важно

- хешируется **только ключ**
- значение **не участвует в навигации**
- хеш-функция зависит от **типа ключа**

---

## Рост map и эвакуация (evacuation)

`map` начинает расти, когда:

- средняя загрузка превышает порог (~6.5 элементов на бакет)
- или становится слишком много overflow-бакетов

### При росте:

- создаётся **новый массив бакетов** (в 2 раза больше)
- старая таблица сохраняется как `oldbuckets`
- элементы **не копируются сразу**
- перенос происходит **постепенно**, во время обычных операций (`get`, `set`, `delete`)

Этот процесс называется **эвакуацией**  
(*incremental rehashing*).

### Преимущества:

- нет долгих пауз
- равномерная нагрузка
- рост прозрачен для пользователя

---

## Алгоритмическая сложность

Средняя (амортизированная) сложность операций:

- чтение: `O(1)`
- запись: `O(1)`
- удаление: `O(1)`

В худшем случае (много коллизий):

- `O(n)`

На практике деградация минимизируетсякачественным хешированием и механизмом `grow`.

## Потокобезопасность

❌ map не потокобезопасна

- одновременная запись → `panic`

- чтение + запись → `panic`

```go
fatal error: concurrent map writes
```

## Работа с map в конкурентной среде
Используют:
- `sync.Mutex`
- `sync.RWMutex`
- `sync.Map` (для специфических сценариев)

```go
var mu sync.Mutex

mu.Lock()
m[key] = value
mu.Unlock()
```

Короткая формула для запоминания

- map = хеш-таблица

- данные лежат в бакетах

- ключ хешируется, значение — нет

- overflow — локально

- grow — рост всей map

- рост через эвакуацию

- средняя сложность O(1)

- map не потокобезопасна

---

  ⬅️ [домой,уолтер](../)
  
