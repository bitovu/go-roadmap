# Map под капотом (Go)

---

## Map в Go — кратко для собеседования

`map` в Go — это **хеш-таблица**.

Внутри она состоит из массива бакетов, каждый из которых хранит до **8 пар ключ-значение**.
Ключ хешируется: младшие биты хеша определяют индекс бакета, а старшие 8 бит используются как `tophash` для ускорения поиска.

**Коллизия** — это одинаковый хеш у разных ключей, а в реализации map это проявляется как попадание разных ключей в один бакет.

Когда средняя загрузка превышает порог, `map` растёт —
создаётся новая таблица бакетов, а элементы переносятся **постепенно** с помощью механизма эвакуации (incremental rehashing).

Операции вставки, поиска и удаления работают за `O(1)` в среднем,
но в худшем случае (при большом количестве коллизий) возможна деградация до `O(n)`.

`map` не потокобезопасна и требует синхронизации при конкурентном доступе.


---

## Общая структура `map`

На уровне реализации `map` включает:

- массив бакетов
- хеш-функцию (зависит от типа ключа)
- счётчик элементов
- структуру для управления ростом (`B`, `oldbuckets`, счётчик эвакуации)

Данные в `map` **не хранятся последовательно** —
они распределяются по бакетам на основе хеша ключа.

---

## Бакеты (buckets)

Каждый бакет содержит:

- до **8 ключей**
- соответствующие значения
- массив `tophash` (8 старших бит хеша ключа)
- указатель на overflow-бакет (если бакет переполнен)

Если в одном бакете больше 8 элементов,
создаётся **overflow-бакет**, связанный с основным.

Overflow — это локальное решение и **не означает рост всей map**.

---

## Хеширование ключей

При добавлении или поиске элемента:

1. **ключ хешируется**
2. младшие биты хеша определяют индекс бакета
3. `tophash` используется как быстрый фильтр внутри бакета
4. при совпадении `tophash` выполняется сравнение реальных ключей

```go
m := make(map[string]int)
m["go"] = 1
```

## Важно

- хешируется **только ключ**
- значение **не участвует в навигации**
- хеш-функция зависит от **типа ключа**

---

## Рост map и эвакуация (evacuation)

`map` начинает расти, когда:

- средняя загрузка превышает порог (~6.5 элементов на бакет)
- или становится слишком много overflow-бакетов

### При росте:

- создаётся **новый массив бакетов** (в 2 раза больше)
- старая таблица сохраняется как `oldbuckets`
- элементы **не копируются сразу**
- перенос происходит **постепенно**, во время обычных операций (`get`, `set`, `delete`)

Этот процесс называется **эвакуацией**  
(*incremental rehashing*).

### Преимущества:

- нет долгих пауз
- равномерная нагрузка
- рост прозрачен для пользователя

---

## Алгоритмическая сложность

Средняя (амортизированная) сложность операций:

- чтение: `O(1)`
- запись: `O(1)`
- удаление: `O(1)`

В худшем случае (много коллизий):

`len(map)` работает за O(1), потому что количество элементов хранится в отдельном поле `count` внутри структуры `hmap`, и `len` просто читает это поле.

- `O(n)`

На практике деградация минимизируетсякачественным хешированием и механизмом `grow`.

## Потокобезопасность

❌ map не потокобезопасна

- одновременная запись → `panic`

- чтение + запись → `panic`

```go
fatal error: concurrent map writes
```

## Работа с map в конкурентной среде
Используют:
- `sync.Mutex`
- `sync.RWMutex`
- `sync.Map` (для специфических сценариев)

```go
var mu sync.Mutex

mu.Lock()
m[key] = value
mu.Unlock()
```

Короткая формула для запоминания

- map = хеш-таблица

- данные лежат в бакетах

- ключ хешируется, значение — нет

- overflow — локально

- grow — рост всей map

- рост через эвакуацию

- средняя сложность O(1)

- map не потокобезопасна

---

  ⬅️ [домой,уолтер](../)
  
